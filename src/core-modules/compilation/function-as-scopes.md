---
nav:
  title: 核心知识
  order: 3
group:
  title: 编译阶段
  order: 2
title: 函数作用域
order: 3
---
# 函数作用域

**函数作用域**指的是属于这个函数的全部变量可以在整个函数的范围内使用及复用(嵌套中的作用域也可以使用)。这种设计方案是非常有用的，能充分利用 JavaScript 变量可以根据需要改变值类型的动态特性。

## 隐藏内部实现

对函数的传统认知就是先声明一个函数，然后再向里面添加代码。但反过来想也可以带来一些启示：从所写的代码中挑选出一个任意的片段，然后用函数声明对它进行包装，实际上就是把这些代码隐藏起来。

实际上，我们每创建一个函数，就会形成一个函数作用域气泡。即这段代码中人设声明都将绑定在这个新创建的函数作用域中。总得来说，可以让一些变量和函数包裹在一个函数作用域中，通过作用域来进行隐藏。

作用：可以隐藏部分的代码中变量和函数声明。

理解：**最小权限原则。**

**最小权限原则**： 应最小限度的暴露必要内容，而隐藏其他信息，模块化或函数的设计。

我们在编码过程中，应该保证我们的变量和函数的私有性，**可以阻止外部作用域对这些变量或函数的不必要访问**。

**改进前**

```js
function doSomething(a){
    b = a + doSomethingElse( a * 2 );

    console.log( b * 3 );
}
function doSomethingElse(a) {
    return a - 1;
}

var b;

doSomething( 2 );	// 15
```

在这个代码片段中，变量 `b` 和函数 `doSomethingElse` 应该是 `doSomething` 内部具体实现的私有内容。给予外部作用域对 `b` 和 `doSomethingElse` 的访问权限不仅没有必要，而且可能是危险的，因为它们可能被有意或无意地以非预期的方式使用，从而导致超出了 `doSomething` 的适用条件。更使用的设计会将这些私有的具体内容隐藏在 `doSomething` 内部。

改进后

```js
function doSomething(a) {
    var b = a + doSomethingElse(a * 2);
    console.log(b * 3);
    
    function doSomethinsElse(a) {
        return a - 1;
    }
}
```

现在，`b` 和 `doSomethingElse` 都无法从外部被访问，而只能被 `doSomething` 所控制。功能性和最终效果都没有受影响，但是设计上将具体内容私有化了，设计良好的软件都会依次进行实现。

## 规避冲突

隐藏作用域中的变量和函数可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致变量的值被意外覆盖。

```js
function foo(){
  function bar(a){
    // 修改 for 循环所属作用域中的 i
    i = 3;
    console.log( a + i );
  }

  for(var i = 0;i < 10; i++){
    // 糟糕，无限循环了！
    bar( i * 2);
  }
}
foo();
```

### 全局命名空间

变量冲突更多的是在全局作用域中。当程序中加载多个第三方库，如果没有做好规范的话，就很容易引起冲突。

这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性，而不是将自己的标识符暴露在顶级的词法作用域中。

```js
const MyReallyCoolLibrary = {
    awesome: 'stuff',
    doSomething: function() {
      	// ...
    },
    doAnotherThing: function() {
        // ...
    }
}
```

### 模块管理

另一种避免冲突的办法就是基于模块机制。就是众多模块管理器中挑选一个来使用。使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器的机制将库的标识符显式地导入到另外一个特定的作用域中。

显而易见，这些工具并没有能够违反词法作用域规则的功能。它们只是利用作用域的规则强制所有标识符都不能注入到共享作用域中，而是保持在私有、无冲突的作用域中，这样可以有效规避掉所有的意外冲突，

因此，只要你愿意，即使不使用任何依赖管理工具也可以实现规避冲突的功效。

在任意代码片段外部添加包装函数，可以将内部的变量和函数定义 **隐藏** 起来，外部作用域无法访问包装函数内部的任何内容。

```js
const a = 2;

function foo() { // <-- 添加这一行
    const a = 3;
    console.log( a );	// 3
}	// <-- 以及这一行
foo();	// <-- 以及这一行

console.log( a );	// 2
```

虽然这种技术可以解决一些问题，但是它并不理想，因为会导致一些额外的问题。首先，必须声明一个具名函数 `foo()` ，意味着 `foo` 这个名称本身"污染"了所在作用域（在这个例子中是全局作用域）。其次，必须显式地通过函数名`foo()`调用这个函数才能运行其中的代码。

如果函数不需要函数名（或者至少函数名可以不污染所在作用域），并且能够自动运行，这将会更加理想。

### 具名和匿名

无论是匿名还是具名，都是针对 **函数表达式** 的。函数声明必须有名称，否则报错。

```js
// 函数声明
function foo() {
    
}
```

**匿名函数表达式**

```js
let foo = () => {
    
}
```

**具名函数表达式**

```js
let bar = function foobar(){
  // do something
};
console.log(bar.name);
// foobar
```

对于函数表达式最熟悉的场景可能就是回调参数了。

```js
setTimeout(function(){
    console.log("I waited 1 second!");
}, 1000);
```

这叫 **匿名函数表达式**，因为 `function(){}` 没有名称标识符。

尽管函数表达式可以是匿名的，而 **函数声明** 是不可以省略函数名。

**匿名函数表达式的缺点**

- 调试的时候不会有具体的函数名，难追踪
- 如果没有函数名，当函数需要引用自身时只能使用已经过期的 `arguments.callee` 引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。
- 匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。

行内函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。给函数表达式指定一个函数名可以有效解决以上问题。始终给函数表达式命名时一个最佳实践。

## 立即执行函数表达式IIFE

**立即执行函数**又叫**自执行函数**, 即**IIFE**

```js
(function() {})();
```

IIFE传递参数

```js
var a = 2;
(function(a) {
    console.log(a);
})(a);
```



