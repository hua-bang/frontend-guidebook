---
nav:
  title: 核心知识
  order: 3
group:
  title: 编译阶段
  order: 2
title: 声明提升
order: 5
---
# 声明提升

JavaScript运行阶段分为`预编译阶段`和`执行阶段`。

在预编译阶段，JavaScript 引擎会做一件事情，那就是读取 `变量的定义` 并 `确定其作用域` 即生效范围。

- **变量定义**
  - 使用`var`或`let`定义的关键字的变量，若未赋值，则为`undefined`
  - 使用`const`关键字定义变量却不赋值，则将抛出错误
- **变量作用域**
  - **全局作用域**遍布全局
  - **函数作用域**只可以用于**自身函数内部**以及**自身函数内嵌套的函数**。
  - 函数内部的同名变量相对于外层变量会**优先访问**。

在JavaScript中，如果变量或函数没有声明就使用，则会报错

```js
console.log(a); 	// referenceError
```

声明提升包括**变量声明提升**还有**函数声明提升**

- 变量声明提升: 使用`var`、`let`和`const`定义的变量在执行前都会被提升到当前作用域的顶部。注意：`var`和 `let`、`const`的提升方式不一样。
- 函数声明提升：函数声明的函数(非函数表达式)在代码执行之前会被提升到当前作用域的顶部，而且**函数声明提升优于变量提升**。

JavaScript 的代码在生成前，会先对代码进行编译，编译的一部分工作就是找到所有的声明，然后建立作用域将其关联起来，因此，在 **当前作用域内** 包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。

注意这里是 **声明** 会被提前处理，**赋值** 并没有， 定义声明是在编译阶段进行的，而赋值是在执行阶段进行的 。也就是说声明提升了，赋值还留着原地，等待执行。

## 变量声明提升

使用`var`定义的变量，会将该声明提取到当前声明的函数作用域的顶部，注意，只是**声明**，并不涉及**赋值**。

**举个例子**

```js
console.log(a);	// undefined
var a = 2;
console.log(a);	//2
```

等价于

```js
var a;
console.log(a);	// undefined
a = 2;
console.log(a);	// 2
```

## 函数声明提升

函数的两种创建方式：

- 函数声明
- 函数表达式

**举个例子：函数声明😊**

```js
foo();
// 输出 'bar'

function foo() {
  console.log('bar');
}
```

**举个例子：函数表达式😊**

```js
foo();
// 报错：foo is not a function

var foo = function (){
  console.log('bar');
}
```

这里只是变量的提升，此时只是将foo的声明提升到当前的作用域的顶部，此时他没有初值，更不是函数，故我们以函数形式去调用的时候，会报错 

**举个例子😊**

```js
var foo = function(){
  console.log('1');
};

function foo(){
  console.log('2');
};

foo();
// '1'
```

我们试着分析一下过程

```js
var foo;
function foo() {
  console.log("1");
}

foo = function() {
  console.log("2");
}
fOO();
```

💡 函数声明提升，会将函数的声明和定义全都提升至作用域顶部。

💡 变量声明提升，只提升声明部分（未赋值状态），赋值部分保持原位置不动。

## 函数覆盖

函数声明和变量声明都会被提升。但是，**函数声明会覆盖变量声明**。

**举个例子😊**

```js
var a;

function a(){}

console.log(a); // 'function a(){}'
```

但是，如果变量存在赋值操作，则最终的值为变量的值

```js
var a = 1;
function a(){}
console.log(a);
```

分析

```js
var a;
function a() {}

a = 1
```

**变量的重复声明是无用的**，但**函数的重复声明会覆盖前面的声明**（无论是变量还是函数声明）

### 重复声明无效

```js
var a = 1;
var a;
console.log(a);
```

输出结果为 1，以上代码等同于：

```js
// 此时 a 的默认值为undefinedvar a;
a = 1;
console.log(a);	// 1
```

### 函数声明优先

由于函数声明提升优先于变量声明提升，所以变量的声明无效。

```js
var a;
function a(){    console.log(1);}
a(); // 1
```

### 函数声明覆盖

后面的函数声明会覆盖前面的函数声明。

```js
a();// 2
function a(){    console.log(1);}
function a(){    console.log(2);}
```

所以，应该避免在同一作用域中重复声明。