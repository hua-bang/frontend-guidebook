---
nav:
  title: 核心知识
  order: 3
group:
  title: 内存管理
  order: 4
title: 垃圾回收
order: 2
---
# 垃圾回收

> 由于字符串、对象和数组没有固定大小，所以当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript 序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript 的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。——《JavaScript 权威指南》

在 C 和 C++ 之类的语言中，需要手动来管理内存的，这也是造成许多不必要问题的根源。幸运的是，在编写 JavaScript 的过程中，内存的分配以及内存的回收完全实现了自动管理。

### JavaScript的内存分配

#### 值的初始化

为了不让程序员费心分配内存，JavaScript 在定义变量时就完成了内存分配。

```js
let a = 1;
let b = 2;
```

#### 值的读取和使用

在业务代码中，总会对变量进行访问和修改

```js
let a = 2;
let b = a;
a = 3;
```

#### 值的释放

当引擎标识这个值不在需要被使用之后，会将这个变量所使用的空间进行回收。（得益于垃圾回收机制）。

JavaScript 通过 **自动垃圾收集机制** 实现内存的管理。垃圾回收机制通过垃圾收集器每隔固定的时间段（周期性）找出那些不再需要继续使用的变量，执行一次释放其占用的内存操作。

> 什么是不再需要继续使用的值？

不再需要继续使用的变量也就是生命周期结束的变量。

- **局部变量：**在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了（除了闭包），因此垃圾收集器很容易做出判断并回收。
- **全局变量：** **但是全局变量的生命周期直到浏览器卸载页面才会结束，也就是全局变量不会被当成垃圾回收**。所以声明一个全局变量的时候，我们一定要慎重的考虑，在使用完这个变量的对象之后，我们是否还在需要这个对象，如果不需要的话，我们应该手动的将这个变量置为空（`null`），这样在下一次垃圾回收的时候，就能去释放这个变量上一次指向的对象（请注意变量与对象的区别）。

## 原理

JavaScript有两种策略实现垃圾回收机制：

- **标记清除法**
- **引用计数法**

### 标记清除法：

**标记清除法**：当程序执行流入到一个函数中时，会创建该函数的执行上下文，执行上下文中的变量都会被标记为 **进入环境**，从逻辑上讲，永远不能释放 **进入执行环境** 变量所占用的内存。因为只要执行流进入相应的执行上下文，就可能会用到这些变量。

标记清除的工作流程：

- 垃圾收集器在运行的时候给存储在内存中的**所有变量加上标记**
- 去掉**执行上下文中的变量**以及**被环境中的变量引用的变量**的标记
- **有标记的变量即为准备删除的变量**
- 最后垃圾收集器完成内存清理工作，销毁带标记的值并回收到他们所占用的内存空间。

手动释放内存：

```js
let a = 1;
a = null;
```

`a = null` 其实仅仅只是做了一个释放引用的操作，让变量 `a` 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。而在适当的时候解除引用，是为页面获得更好性能的一个重要方式。

### 引用计数法：

引用计数法：实质上就是取跟踪每个变量被引用的情况。当我们声明一个变量时，他的引用数为0，而当他被其他变量所引用，每次引用会将引用数+1.相反，如果取消了对这个数的引用，则会-1，当这个变量的引用次数为0，就表明没有人再引用这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为 0 的值所占的内存。

这种垃圾收集方式存在一个比较大的问题就是循环引用，就是说对象 `a` 包含一个指向 `b` 的指针，对象 `b` 也包含一个指向 `a` 的引用。 这就可能造成大量内存得不到回收（内存泄漏），因为它们的引用次数永远不可能是 0 。

```js
function problem() {
  var a = new Object();
  var b = new Object();
  a.ref = b;
  b.ref = a;
}
```

## 堆栈溢出

**堆栈溢出**：指内存空间已经被申请完，没有足够的内存提供了。

## 内存泄漏

注意： 内存泄漏不等于堆栈溢出，但内存泄漏可能引起堆栈溢出。

**内存泄漏**：指申请的内存执行完后没有及时的清理或者销毁，占用空闲内存，内存泄漏过多的话，就会导致后面的进程申请不到内存。因此内存泄漏会导致内部内存溢出。

在传统的编程软件中，比如 C 语言中，需要使用 `malloc` 来申请内存空间，再使用 `free` 来释放掉，需要手动清除。而 JavaScript 中有自己的垃圾回收机制，一般常用的垃圾收集方法就是标记清除法。

- 即使 1Byte 的内存，也叫内存泄漏，并不一定是导致浏览器奔溃、卡顿才能叫内存泄漏
- 一般是堆区内存泄漏，栈区不会泄漏。基本数据类型的值保存在栈中，引用数据类型保存在堆中。所以对象、数组等才会发生内存泄漏。

**常见内存泄漏的原因**：

- 全局变量引起的内存泄漏
- 没有被清理的定时器和事件
- 闭包

**解决方法：**

- 减少不必要的全局变量
- 减少闭包的使用（因为闭包会导致内存泄漏）
- 避免死循环的发生

### 全局变量

全局变量不会被当成垃圾回收，我们在编码中应该尽量避免声明全局变量。

```js
function foo() {  
  // 默认绑定 => window.bar = 10  
  this.bar = 10;  // 没有显式声明变量 
  // 实际是全局变量 => window.baz = 20  
  baz = 20;
}
foo();
```

当我们使用 [默认绑定](https://tsejx.github.io/javascript-guidebook/core-modules/executable-code-and-execution-contexts/execution/this#默认绑定)，`this` 会指向全局对象。

🔧 **解决方法：** 在函数内使用严格模式或手动释放全局变量的内存。

### 定时器

对于定义的`setTimeout`和`setInterval`要及时清理，如果没有及时清理，定时器内部的函数，即函数内部引用依赖的变量，都不会被回收，造成内存泄漏。

**解决方法**：在定时器完成工作的时候，手动清除定时器。

### 闭包

闭包可以维持函数内局部变量，使其得不到释放，造成内存泄漏。

```js
function bindEvent() {
  const o = document.createElement('foo');
  const unused = function() {
    // 闭包内引用变量 o 将不会释放
    console.log(o);
  };
}
```

🔧 **解决方法**：手动解除引用 `o = null`

---

**参考资料：**

- [垃圾回收](https://tsejx.github.io/javascript-guidebook/core-modules/executable-code-and-execution-contexts/memory-management/garbage-collection)
- [内存管理](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management)